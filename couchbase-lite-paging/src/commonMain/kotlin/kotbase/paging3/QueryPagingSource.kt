/*
 * Based on https://github.com/cashapp/sqldelight/blob/master/extensions/androidx-paging3/src/commonMain/kotlin/app/cash/sqldelight/paging3/QueryPagingSource.kt
 */

@file:Suppress("FunctionName")

package kotbase.paging3

import app.cash.paging.PagingSource
import kotbase.Database
import kotbase.From
import kotbase.GroupBy
import kotbase.Having
import kotbase.Joins
import kotbase.OrderBy
import kotbase.Query
import kotbase.Select
import kotbase.Where
import kotbase.molo17.limit
import kotlin.coroutines.CoroutineContext
import kotlin.jvm.JvmName

/**
 * Create a [PagingSource] that pages through all results from the `database`. Queries
 * will be executed without join, where, order by, or group by clauses. Call a version
 * of `QueryPagingSource` that takes a `queryProvider` in order to append these clauses
 * to the paging queries. The [PagingSource] will do SQL offset/limit based paging. Use
 * the `select` statement and `mapper` to map paged documents to objects.
 *
 * Queries will be executed on `context`.
 */
public fun <RowType : Any> QueryPagingSource(
    select: Select,
    database: Database,
    mapper: (Map<String, Any?>) -> RowType,
    context: CoroutineContext
): PagingSource<Int, RowType> = OffsetQueryPagingSource(
    select,
    database,
    { FromLimitQueryProvider(this) },
    mapper,
    context
)

private class FromLimitQueryProvider(private val from: From) : LimitQueryProvider, Query by from {
    override fun limit(limit: Int, offset: Int): Query = from.limit(limit, offset)
}

/**
 * Create a [PagingSource] that pages through results according to queries generated by
 * `queryProvider`. `queryProvider` receives a select from `database` and should append
 * any necessary SQL join, where, order by, and group by clauses. Queries returned by
 * `queryProvider` should expect the [PagingSource] to do SQL offset/limit based paging.
 * `queryProvider` will be called multiple times both as a count query for total records
 * as well as with the `select` statement with page offsets to retrieve documents, which
 * are mapped to objects via the provided `mapper`.
 *
 * Queries will be executed on `context`.
 */
@JvmName("QueryPagingSourceJoins")
public fun <RowType : Any> QueryPagingSource(
    select: Select,
    database: Database,
    mapper: (Map<String, Any?>) -> RowType,
    context: CoroutineContext,
    queryProvider: From.() -> Joins
): PagingSource<Int, RowType> = OffsetQueryPagingSource(
    select,
    database,
    { JoinsLimitQueryProvider(queryProvider()) },
    mapper,
    context
)

private class JoinsLimitQueryProvider(private val joins: Joins) : LimitQueryProvider, Query by joins {
    override fun limit(limit: Int, offset: Int): Query = joins.limit(limit, offset)
}

/**
 * Create a [PagingSource] that pages through results according to queries generated by
 * `queryProvider`. `queryProvider` receives a select from `database` and should append
 * any necessary SQL join, where, order by, and group by clauses. Queries returned by
 * `queryProvider` should expect the [PagingSource] to do SQL offset/limit based paging.
 * `queryProvider` will be called multiple times both as a count query for total records
 * as well as with the `select` statement with page offsets to retrieve documents, which
 * are mapped to objects via the provided `mapper`.
 *
 * Queries will be executed on `context`.
 */
@JvmName("QueryPagingSourceWhere")
public fun <RowType : Any> QueryPagingSource(
    select: Select,
    database: Database,
    mapper: (Map<String, Any?>) -> RowType,
    context: CoroutineContext,
    queryProvider: From.() -> Where
): PagingSource<Int, RowType> = OffsetQueryPagingSource(
    select,
    database,
    { WhereLimitQueryProvider(queryProvider()) },
    mapper,
    context
)

private class WhereLimitQueryProvider(private val where: Where) : LimitQueryProvider, Query by where {
    override fun limit(limit: Int, offset: Int): Query = where.limit(limit, offset)
}

/**
 * Create a [PagingSource] that pages through results according to queries generated by
 * `queryProvider`. `queryProvider` receives a select from `database` and should append
 * any necessary SQL join, where, order by, and group by clauses. Queries returned by
 * `queryProvider` should expect the [PagingSource] to do SQL offset/limit based paging.
 * `queryProvider` will be called multiple times both as a count query for total records
 * as well as with the `select` statement with page offsets to retrieve documents, which
 * are mapped to objects via the provided `mapper`.
 *
 * Queries will be executed on `context`.
 */
@JvmName("QueryPagingSourceGroupBy")
public fun <RowType : Any> QueryPagingSource(
    select: Select,
    database: Database,
    mapper: (Map<String, Any?>) -> RowType,
    context: CoroutineContext,
    queryProvider: From.() -> GroupBy
): PagingSource<Int, RowType> = OffsetQueryPagingSource(
    select,
    database,
    { GroupByLimitQueryProvider(queryProvider()) },
    mapper,
    context
)

private class GroupByLimitQueryProvider(private val groupBy: GroupBy) : LimitQueryProvider, Query by groupBy {
    override fun limit(limit: Int, offset: Int): Query = groupBy.limit(limit, offset)
}

/**
 * Create a [PagingSource] that pages through results according to queries generated by
 * `queryProvider`. `queryProvider` receives a select from `database` and should append
 * any necessary SQL join, where, order by, and group by clauses. Queries returned by
 * `queryProvider` should expect the [PagingSource] to do SQL offset/limit based paging.
 * `queryProvider` will be called multiple times both as a count query for total records
 * as well as with the `select` statement with page offsets to retrieve documents, which
 * are mapped to objects via the provided `mapper`.
 *
 * Queries will be executed on `context`.
 */
@JvmName("QueryPagingSourceHaving")
public fun <RowType : Any> QueryPagingSource(
    select: Select,
    database: Database,
    mapper: (Map<String, Any?>) -> RowType,
    context: CoroutineContext,
    queryProvider: From.() -> Having
): PagingSource<Int, RowType> = OffsetQueryPagingSource(
    select,
    database,
    { HavingLimitQueryProvider(queryProvider()) },
    mapper,
    context
)

private class HavingLimitQueryProvider(private val having: Having) : LimitQueryProvider, Query by having {
    override fun limit(limit: Int, offset: Int): Query = having.limit(limit, offset)
}

/**
 * Create a [PagingSource] that pages through results according to queries generated by
 * `queryProvider`. `queryProvider` receives a select from `database` and should append
 * any necessary SQL join, where, order by, and group by clauses. Queries returned by
 * `queryProvider` should expect the [PagingSource] to do SQL offset/limit based paging.
 * `queryProvider` will be called multiple times both as a count query for total records
 * as well as with the `select` statement with page offsets to retrieve documents, which
 * are mapped to objects via the provided `mapper`.
 *
 * Queries will be executed on `context`.
 */
@JvmName("QueryPagingSourceOrderBy")
public fun <RowType : Any> QueryPagingSource(
    select: Select,
    database: Database,
    mapper: (Map<String, Any?>) -> RowType,
    context: CoroutineContext,
    queryProvider: From.() -> OrderBy
): PagingSource<Int, RowType> = OffsetQueryPagingSource(
    select,
    database,
    { OrderByLimitQueryProvider(queryProvider()) },
    mapper,
    context
)

private class OrderByLimitQueryProvider(private val orderBy: OrderBy) : LimitQueryProvider, Query by orderBy {
    override fun limit(limit: Int, offset: Int): Query = orderBy.limit(limit, offset)
}
